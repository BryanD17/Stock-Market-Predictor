# -*- coding: utf-8 -*-
"""Stock Market Predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sybz3RMYTTeyOAqHK_Sb0FGMs-MhVjxS

#  READ ME

---



##Predicting linear regression model

###1) Intro
#  

  #### Dataset information & why did you choose it :
#     
We are currently in the process of developing a stock prediction model for Rivian stock. This model aims to forecast the future price movements of Rivian stock, predicting whether it will rise or decline in the near future.         
To begin this endeavor, our first step involved sourcing the necessary stock data for Rivian and converting it into a CSV file for seamless integration into our code. As Rivian operates in the automotive industry, we also acquired stock data for its prominent competitors, namely Tesla and Nio. Similar CSV files were created for these companies to enable a comparative analysis. By leveraging this data and employing advanced analytical techniques, we aim to create a robust prediction model that will assist investors and stakeholders in making informed decisions regarding Rivian stock. Our ultimate goal is to provide valuable insights into the potential future performance of Rivian in the stock market..
#   

###2) Exploratory Analysis
#  
#### Types of Variable:
#   
Within our project, we employed a variety of dictionaries to effectively manage and organize our data. Additionally, we incorporated several diverse libraries to facilitate Natural Language Processing (NLP) capabilities, enabling us to work with and analyze human language effectively.


#### Descriptive statistics
#  
To analyze the dispersion of stock prices for Rivian, Tesla, and Nio, we employ descriptive statistics, specifically the standard deviation.      
This measures the variation within each company's stock prices. We gather recent historical stock price data for the three companies and calculate their respective means. Then, we find the differences between each stock price and its mean, square these differences, and average them to compute the variance.   
Finally, we take the square root of the variance to obtain the standard deviation. This metric reveals how far apart each company's stock prices are from their mean, indicating volatility or stability. By following this process, we can determine the recent price performance of Rivian, Tesla, and Nio in the market.

#### Plots
#  
To analyze ongoing trends in the recent stock prices of Rivian, Tesla, and Nio, we'll use scatter plots—an essential data visualization tool in computer science. By plotting the stock prices against time, we can easily identify patterns and trends. An upward slope suggests increasing prices, a downward slope indicates decreasing prices, while scattered data points imply volatility or no clear trend. This visual analysis provides valuable insights for making informed investment decisions.
###3) Models - Inferences
#   
  #### Statistical Models used -
  To analyze and identify trends in the stock prices of Rivian, Tesla, and Nio, we use linear regression—a statistical technique in computer science. By fitting a straight line to each company's stock price data over time, we can determine the trend and direction of their prices. Positive slopes indicate increasing prices, negative slopes suggest declining prices, and flat lines represent stability. Linear regression allows for accurate plotting and data-driven decision-making in financial analysis and investment strategies.
  #   
  ####  Algorithm -
  To perform the analysis, we utilized a Natural Language Processor (NLP) algorithm, a powerful tool in the field of natural language understanding and processing. This algorithm was applied to interpret and process textual data, specifically financial news articles and reports related to Rivian, Tesla, and Nio.


1.   Data Collection: The NLP algorithm collects financial news articles and reports from various sources, encompassing recent data related to the stock prices of Rivian, Tesla, and Nio.




###4) Conclusion/Discussion

#   
By integrating the NLP algorithm into the analysis, we can effectively process and extract valuable insights from vast amounts of textual data, enhancing the accuracy and depth of our understanding of the stock performance of Rivian, Tesla, and Nio. This advanced data processing methodology empowers us to make informed investment decisions and derive actionable intelligence from complex financial information in the domain of computer science and natural language processing.

# Data Frame Initialization
"""

tesla: "https://docs.google.com/spreadsheets/d/e/2PACX-1vT8lLj4Uj25SNNlBKzw3SOoAQ6XekFAJHOhpRrV1oHKtJF7IepXMBIvvw7NmR0CbAUFRgtEzLEBq5Yg/pub?gid=919686597&single=true&output=csv"
nio: "https://docs.google.com/spreadsheets/d/e/2PACX-1vTBnSndHE5O4nl-0rjnvhHdiHYRNQmZJc7TuGpSrRrB4ZliUHxOn78dFFCKN-GsGHL3YEYnOORFNOMI/pub?gid=1494610544&single=true&output=csv"
rivian: "https://docs.google.com/spreadsheets/d/e/2PACX-1vQxKXslLJmvCPz33ZBlpnM7Ny6ToKW9aL_PkmfXF18govNqjR__pT-ziLG3QcykK8lsByGyTWYM_JMj/pub?gid=1117867660&single=true&output=csv"

#@title Default title text
import pandas as pd
import random
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score
import sklearn
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn import linear_model
from sklearn import preprocessing
from sklearn import utils
from keras.models import Sequential
from keras.layers import Dense, Conv2D
from keras.layers import Activation, MaxPooling2D, Dropout, Flatten, Reshape
from sklearn.preprocessing import PolynomialFeatures
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from keras.wrappers.scikit_learn import KerasClassifier
import tensorflow.keras as keras



tesla_df = pd.read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vT8lLj4Uj25SNNlBKzw3SOoAQ6XekFAJHOhpRrV1oHKtJF7IepXMBIvvw7NmR0CbAUFRgtEzLEBq5Yg/pub?gid=919686597&single=true&output=csv")
nio_df = pd.read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vTBnSndHE5O4nl-0rjnvhHdiHYRNQmZJc7TuGpSrRrB4ZliUHxOn78dFFCKN-GsGHL3YEYnOORFNOMI/pub?gid=1494610544&single=true&output=csv")
rivn_df = pd.read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vQxKXslLJmvCPz33ZBlpnM7Ny6ToKW9aL_PkmfXF18govNqjR__pT-ziLG3QcykK8lsByGyTWYM_JMj/pub?gid=1117867660&single=true&output=csv")
for i in range(len(rivn_df)):
    rivn_df.at[i, 'Date'] = i
for i in range(len(tesla_df)):
  tesla_df.at[i, "Date"] = i

def CNNClassifier(num_epochs=30, layers=4, dropout=0.5):
  def create_model():
    model = Sequential()
    model.add(Reshape((32, 32, 3)))

    for i in range(layers):
      model.add(Conv2D(32, (3, 3), padding='same'))
      model.add(Activation('relu'))

    model.add(Conv2D(32, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(dropout))

    model.add(Conv2D(64, (3, 3), padding='same'))
    model.add(Activation('relu'))
    model.add(Conv2D(64, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(dropout))

    model.add(Flatten())
    model.add(Dense(512))
    model.add(Activation('relu'))
    model.add(Dropout(dropout))
    model.add(Dense(2))
    model.add(Activation('softmax'))

    # initiate RMSprop optimizer
    opt = keras.optimizers.legacy.RMSprop(learning_rate=0.0001, decay=1e-6) #Original optimizer
    #opt =

    # Let's train the model using RMSprop
    model.compile(loss='categorical_crossentropy',
                  optimizer=opt,
                  metrics=['accuracy'])
    print("Model sucessfully built")
    return model
  #opt = keras.optimizers.Adam(learning_rate=0.0001)
  return KerasClassifier(build_fn=create_model ,epochs=num_epochs, batch_size=10, verbose=2)

# This is a data chart of the Tesla Stock summary, it includes details of when TSLA reached it's highest and lowest prices
tesla_df.head()

# This is a data chart of the NIO Stock summary, it includes details of when Nio reached it's highest and lowest prices
nio_df.head()

# This is a data chart of the Rivian Stock summary, it includes details of when Rivn reached it's highest and lowest prices
rivn_df.head()

"""## Test


"""

# Created a scatter plot to visualize the trends (Highest and Lowest Prices) that the stock Rivian has made in the past Years
sns.scatterplot(x = 'Date', y = 'Close', data = rivn_df)

X = ['Open', 'Volume']
y = 'Close'
xs = rivn_df.iloc[:, 0:1].values
Ys = rivn_df.iloc[:, 2].values


# 1. Split data into train and test
train_df, test_df = train_test_split(rivn_df, test_size = 0.2, random_state = 1)

# 2. Prepare your X_train, X_test, y_train, and y_test variables
# by extracting the appropriate columns:
X_train = train_df[X]
y_train = train_df[y]
X_test = test_df[X]
y_test = test_df[y]

# 3. Initialize the model object
linear_model = LinearRegression()

poly = PolynomialFeatures(degree=10)
X_poly = poly.fit_transform(xs)

poly.fit(X_poly, Ys)
linear_model.fit(X_poly, Ys)

# Visualising the Polynomial Regression results
plt.scatter(xs, Ys, color='green')

plt.plot(xs, linear_model.predict(poly.fit_transform(xs)),
         color='red')
plt.title('Polynomial Regression')
plt.xlabel('Date')
plt.ylabel('Close')

plt.show()

# 4. Fit the model to the training data
linear_model.fit(X_train, y_train)

# 5. Use this trained model to predict on the test data
y_pred = linear_model.predict(X_test)[0]

print(y_pred)

X = ['Open', 'Volume']
y = 'Close'
xs = tesla_df.iloc[:, 0:1].values
Ys = tesla_df.iloc[:, 2].values


# 1. Split data into train and test
train_df, test_df = train_test_split(tesla_df, test_size = 0.2, random_state = 1)

# 2. Prepare your X_train, X_test, y_train, and y_test variables by extracting the appropriate columns:
X_train = train_df[X]
y_train = train_df[y]
X_test = test_df[X]
y_test = test_df[y]

# 3. Initialize the model object
linear_model = LinearRegression()

poly = PolynomialFeatures(degree=10)
X_poly = poly.fit_transform(xs)

poly.fit(X_poly, Ys)
linear_model.fit(X_poly, Ys)

# Visualising the Polynomial Regression results
plt.scatter(xs, Ys, color='purple')

plt.plot(xs, linear_model.predict(poly.fit_transform(xs)),
         color='green')
plt.title('Polynomial Regression')
plt.xlabel('Date')
plt.ylabel('Close')

plt.show()

# 4. Fit the model to the training data
linear_model.fit(X_train, y_train)

# 5. Use this trained model to predict on the test data
y_pred = linear_model.predict(X_test)[0]

print(y_pred)

X = ['Open', 'Volume']
y = 'Close'
xs = tesla_df.iloc[:, 0:1].values
Ys = tesla_df.iloc[:, 2].values


# 1. Split data into train and test
train_df, test_df = train_test_split(nio_df, test_size = 0.2, random_state = 1)

# 2. Prepare your X_train, X_test, y_train, and y_test variables by extracting the appropriate columns:
X_train = train_df[X]
y_train = train_df[y]
X_test = test_df[X]
y_test = test_df[y]

# 3. Initialize the model object
linear_model = LinearRegression()

poly = PolynomialFeatures(degree=10)
X_poly = poly.fit_transform(xs)

poly.fit(X_poly, Ys)
linear_model.fit(X_poly, Ys)

# Visualising the Polynomial Regression results
plt.scatter(xs, Ys, color='purple')

plt.plot(xs, linear_model.predict(poly.fit_transform(xs)),
         color='green')
plt.title('Polynomial Regression')
plt.xlabel('Date')
plt.ylabel('Close')

plt.show()

# 4. Fit the model to the training data
linear_model.fit(X_train, y_train)

# 5. Use this trained model to predict on the test data
y_pred = linear_model.predict(X_test)[0]

print(y_pred)

import pandas as pd
import requests
from io import StringIO
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from datetime import datetime
from prophet import Prophet
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error
import numpy as np

# Function to load CSV data from URL
def load_csv_from_url(url):
    response = requests.get(url)
    return pd.read_csv(StringIO(response.text))

# Load CSV data
url = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQxKXslLJmvCPz33ZBlpnM7Ny6ToKW9aL_PkmfXF18govNqjR__pT-ziLG3QcykK8lsByGyTWYM_JMj/pub?gid=1117867660&single=true&output=csv"
df = load_csv_from_url(url)

# Convert 'Date' column to datetime type
df['Date'] = pd.to_datetime(df['Date'])

# Set 'Date' as the index
df.set_index('Date', inplace=True)

# Handle missing values, if any (forward fill for simplicity)
df.fillna(method='ffill', inplace=True)

# Create a new DataFrame with 'ds' and 'y' columns required by Prophet
prophet_df = df.reset_index().rename(columns={'Date': 'ds', 'Close': 'y'})

# Create and fit the Prophet model
model = Prophet()
model.fit(prophet_df)

# Function to make a prediction for the given date
def predict_rivn_close_price(input_date):
    # Create a DataFrame with the input date for prediction
    future = pd.DataFrame({'ds': [input_date]})

    # Make a prediction for the input date
    forecast = model.predict(future)

    # Extract the predicted 'yhat' value (forecasted close price)
    predicted_close = forecast.loc[0, 'yhat']
    return predicted_close

# User input date for prediction
user_input_date = input("Enter the date (YYYY-MM-DD) for RIVN 'Close' price prediction: ")
input_date = datetime.strptime(user_input_date, "%Y-%m-%d")
prediction = predict_rivn_close_price(input_date)
print(f"Predicted RIVN 'Close' price for {input_date.date()}: ${prediction:.2f}")

plot_graph()

def predict_stock_prices(symbol, start_date, end_date, periods=365):
    # Fetch historical stock price data using yfinance
    stock_data = yf.download(symbol, start=start_date, end=end_date)

    # Prepare data for Prophet
    df = stock_data[["Close"]].copy()
    df.reset_index(inplace=True)
    df.rename(columns={"Date": "ds", "Close": "y"}, inplace=True)

    # Initialize Prophet model
    model = Prophet(daily_seasonality=True)

    # Fit the model with the data
    model.fit(df)

    # Create future dates to make predictions for
    future = model.make_future_dataframe(periods=periods)

    # Make predictions
    forecast = model.predict(future)

    # Extract relevant columns from the forecast
    forecast_data = forecast[["ds", "yhat", "yhat_lower", "yhat_upper"]]

    # Evaluate model performance
    actual_data = stock_data[stock_data.index >= stock_data.index.max()]
    mae = mean_absolute_error(actual_data["Close"], forecast_data["yhat"].tail(len(actual_data)))
    mse = mean_squared_error(actual_data["Close"], forecast_data["yhat"].tail(len(actual_data)))
    rmse = np.sqrt(mse)

    return forecast_data, mae, mse, rmse

def plot_stock_prices(actual_data, forecast_data, symbol):
    plt.figure(figsize=(12, 6))
    plt.plot(actual_data.index, actual_data["Close"], label="Actual Stock Price", color='blue')
    plt.plot(forecast_data["ds"], forecast_data["yhat"], label="Predicted Stock Price", color='red')
    plt.fill_between(forecast_data["ds"], forecast_data["yhat_lower"], forecast_data["yhat_upper"], color='pink', alpha=0.3)
    plt.xlabel("Date")
    plt.ylabel("Stock Price")
    plt.title(f"Stock Price Prediction for {symbol}")
    plt.legend()
    plt.grid(True)
    plt.show()

def predict_stock_price_for_date(model, date):
    future = pd.DataFrame({'ds': [date]})
    forecast = model.predict(future)
    predicted_price = forecast.loc[0, 'yhat']
    return predicted_price

def predict_stock_prices(symbol, start_date, end_date, periods=365):
    # Fetch historical stock price data using yfinance
    stock_data = yf.download(symbol, start=start_date, end=end_date)

    # Prepare data for Prophet
    df = stock_data[["Close"]].copy()
    df.reset_index(inplace=True)
    df.rename(columns={"Date": "ds", "Close": "y"}, inplace=True)

    # Initialize Prophet model
    model = Prophet(daily_seasonality=True)

    # Fit the model with the data
    model.fit(df)

    # Create future dates to make predictions for
    future = model.make_future_dataframe(periods=periods)

    # Make predictions
    forecast = model.predict(future)

    # Extract relevant columns from the forecast
    forecast_data = forecast[["ds", "yhat", "yhat_lower", "yhat_upper"]]

    # Evaluate model performance
    actual_data = stock_data[stock_data.index >= stock_data.index.max()]
    mae = mean_absolute_error(actual_data["Close"], forecast_data["yhat"].tail(len(actual_data)))
    mse = mean_squared_error(actual_data["Close"], forecast_data["yhat"].tail(len(actual_data)))
    rmse = np.sqrt(mse)

    return forecast_data, mae, mse, rmse, model

def plot_stock_prices(actual_data, forecast_data, symbol, input_date):
    plt.figure(figsize=(12, 6))
    plt.plot(actual_data.index, actual_data["Close"], label="Actual Stock Price", color='blue')
    plt.plot(forecast_data["ds"], forecast_data["yhat"], label="Predicted Stock Price", color='red')
    plt.fill_between(forecast_data["ds"], forecast_data["yhat_lower"], forecast_data["yhat_upper"], color='pink', alpha=0.3)
    plt.xlabel("Date")
    plt.ylabel("Stock Price")
    plt.title(f"Stock Price Prediction for {symbol}")
    plt.legend()
    plt.grid(True)
    predicted_price = predict_stock_price_for_date(model, input_date)
    print(f"Predicted stock price for {input_date}: ${predicted_price:.2f}")
    datereal = forecast_data[forecast_data["ds"]==input_date]
    plt.plot(datereal["ds"], predicted_price, marker="o", markersize=8, markeredgecolor="black", markerfacecolor="green")
    plt.show()

def predict_stock_price_for_date(model, date):
    future = pd.DataFrame({'ds': [date]})
    forecast = model.predict(future)
    predicted_price = forecast.loc[0, 'yhat']

    return predicted_price

symbol = "AAPL"
start_date = "2010-01-01"
end_date = "2023-07-28"
periods = 365
input_date = "2023-08-01"

forecast_data, mae, mse, rmse, model = predict_stock_prices(symbol, start_date, end_date, periods)
print("Mean Absolute Error (MAE):", mae)
print("Mean Squared Error (MSE):", mse)
print("Root Mean Squared Error (RMSE):", rmse)

actual_data = yf.download(symbol, start=start_date, end=end_date)
plot_stock_prices(actual_data, forecast_data, symbol, input_date)